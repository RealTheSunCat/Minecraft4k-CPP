#version 430
layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;
layout(r8ui, binding = 1) uniform uimage3D world;


#define AXIS_X 0
#define AXIS_Y 1
#define AXIS_Z 2

#define BLOCK_AIR 0

struct Camera
{
    float cosYaw;
    float cosPitch;
    float sinYaw;
    float sinPitch;
};

uniform vec2 screenSize;
uniform Camera camera;
uniform vec2 frustumDiv;
uniform vec3 playerPos;

uniform sampler2D textureAtlas;

uniform vec3 lightDirection;

uniform vec3 sunColor;
uniform vec3 ambColor;
uniform vec3 skyColor;

vec3 raytrace(in ivec2 pixel_coords)
{
    const vec2 frustumRay = (pixel_coords - (0.5 * screenSize)) / frustumDiv;
    
    // rotate frustum space to world space
    const float temp = camera.cosPitch + frustumRay.y * camera.sinPitch;
    
    vec3 rayDir = normalize(vec3(frustumRay.x * camera.cosYaw + temp * camera.sinYaw,
                                 frustumRay.y * camera.cosPitch - camera.sinPitch,
                                 temp * camera.cosYaw - frustumRay.x * camera.sinYaw));
    
    const float sunDot = clamp(dot(rayDir, lightDirection), 0, 1);

    float fogIntensity = 0.0f;
    float lightIntensity = 1.0f;
    vec3 pixelColor;
    
    float furthestHit = RENDER_DIST;
    vec3 closestHit = vec3(-1);
    
    bool wasBlockHit = false;
    
    vec3 rayOrigin = playerPos;
    
    for(int pass = 0; pass < 2; pass++)
    {

        bool skipRestOfPass = false;
        for(int axis = 0; axis < 3; axis++)
        {
            // align ray to block edge on this axis
            // and calc ray deltas
            const float delta = rayDir[axis];
            
            const vec3 rayDelta = rayDir / abs(delta);
            
            const float playerOffsetFromBlockEdge = delta > 0 ? 1.0f - fract(rayOrigin[axis]) : fract(rayOrigin[axis]);
            
            vec3 rayPos = rayOrigin + rayDelta * playerOffsetFromBlockEdge;

            rayPos[axis] -= delta < 0 ? 1 : 0;
            
            float rayTravelDist = playerOffsetFromBlockEdge / abs(delta);

            // do the raycast
            while (rayTravelDist < furthestHit)
            {
                const ivec3 blockHit = ivec3(rayPos.x - WORLD_SIZE, rayPos.y - WORLD_HEIGHT, rayPos.z - WORLD_SIZE);

                // if ray exits the world
                if (blockHit.x < 0 || blockHit.y < -2 || blockHit.z < 0 || blockHit.x >= WORLD_SIZE || blockHit.y >= WORLD_HEIGHT || blockHit.z >= WORLD_SIZE)
                    break;
                
                const int blockHitID = blockHit.y < 0 ? BLOCK_AIR : int(imageLoad(world, blockHit).x);

                if (blockHitID != BLOCK_AIR)
                {
                    const int texFetchX = int((axis != AXIS_Y) ? int(mod((rayPos.x + rayPos.z) * TEXTURE_RES, TEXTURE_RES)) :
                                                        int(mod(rayPos.x * TEXTURE_RES, TEXTURE_RES)));
                    const int texFetchY = int((axis != AXIS_Y) ? int(mod(rayPos.y * TEXTURE_RES, TEXTURE_RES) + TEXTURE_RES) :
                                                        int(mod(rayPos.z * TEXTURE_RES, TEXTURE_RES)) + (rayDelta.y < 0.0F ? TEXTURE_RES * 2 : 0));

                    const vec3 textureColor = texture(textureAtlas, vec2(
                                                        texFetchX / float(TEXTURE_RES), 
                                                        (texFetchY + TEXTURE_RES * 3 * blockHitID) / float(TEXTURE_RES * 48))).xyz;
                    
                    bool texturesPass = pass == 0;

                    if (dot(textureColor, textureColor) != 0) { // pixel is not transparent
                        pixelColor = texturesPass ? textureColor : pixelColor;
                        fogIntensity = texturesPass ? (rayTravelDist / RENDER_DIST) : fogIntensity;
                        wasBlockHit = texturesPass ? true : wasBlockHit;
                        
                        lightIntensity = texturesPass ? lightIntensity : 0.25f;
                        skipRestOfPass = texturesPass ? skipRestOfPass : true;

                        // break out of while loop with this
                        rayTravelDist = texturesPass ? rayTravelDist : furthestHit + 1;
                    }
                    
                    furthestHit = rayTravelDist;
                    closestHit = rayPos;
                    lightIntensity = texturesPass ? 1 + (-sign(delta) * lightDirection[axis]) / 2.0f : lightIntensity;
                }

                rayPos += rayDelta;
                rayTravelDist += 1.0f / abs(delta);
            }
            
            if(skipRestOfPass)
                break;
        }
                    
        if(!wasBlockHit || skipRestOfPass) // don't do sky shadows
            break;
                    
        // TODO why?
        if(lightIntensity <= 0.5f)
            break;
        
        // prepare for shadows pass
        rayOrigin = closestHit;
        rayDir = lightDirection;
        furthestHit = RENDER_DIST;
    }
    
    return wasBlockHit ? mix(pixelColor, skyColor, fogIntensity) * mix(ambColor, sunColor, lightIntensity)
                       : mix(skyColor, sunColor, 0.5 * pow(sunDot + 0.2, 5));
}

void main() {
    // get index in global work group i.e x,y position
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    
    vec4 pixel = vec4(raytrace(pixel_coords), 1);
    
    // output to image
    imageStore(img_output, pixel_coords, pixel);
}