#version 430
layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba32f, binding = 0) uniform image2D img_output;
layout(r8ui, binding = 1) uniform uimage3D blockData;

//! #define WORLD_SIZE 64
//! #define WORLD_HEIGHT 64

#define BLOCK_AIR 0

uniform sampler2D textureAtlas;

struct Camera
{
    vec3 pos;
    float cosYaw;
    float cosPitch;
    float sinYaw;
    float sinPitch;
    vec2 frustumDiv;
};

uniform vec2 screenSize;
uniform Camera camera;

// get the block at the specified position in the world
int getBlock(ivec3 coords)
{
    return int(imageLoad(blockData, coords).x);
}

bool inWorld(ivec3 pos)
{
    const vec3 lessThanWorld = step(vec3(0, -2, 0), pos);
    const vec3 greaterThanWorld = step(vec3(WORLD_SIZE, WORLD_HEIGHT, WORLD_SIZE), pos);

    return dot(lessThanWorld, lessThanWorld) * dot(greaterThanWorld, greaterThanWorld) == 0;
}

#define AXIS_X 0
#define AXIS_Y 1
#define AXIS_Z 2

// ~~stolen~~ took "inspiration" from https://github.com/Vercidium/voxel-ray-marching/blob/master/source/Map.cs

// Voxel ray marching from http://www.cse.chalmers.se/edu/year/2010/course/TDA361/grid.pdf
// Optimized by keeping block lookups within the current chunk, which minimises bitshifts, masks and multiplication operations
vec3 rayMarch(in vec3 start, vec3 velocity, float maximum, out bool hit, out int axis)
{
    ivec3 iStart = ivec3(start);

    if (!inWorld(iStart))
    {
        hit = false;
        return vec3(1, 0, 0);
    }
    

    // Determine the chunk-relative position of the ray using a bit-mask
    int i = iStart.x - WORLD_SIZE / 2;
    int j = iStart.y - WORLD_HEIGHT / 2;
    int k = iStart.z - WORLD_SIZE / 2;

    // Calculate the end position of the ray
    vec3 end = start + velocity;

    // If the start and end positions of the ray both lie on the same coordinate on the voxel grid
    if (iStart == end)
    {
        // If the block is empty
        if (getBlock(ivec3(i, j, k)) == BLOCK_AIR)
        {
            hit = false;
        }

        // Else the ray begins and ends within the same non-empty block
        else
        {
            hit = true;
        }

        return vec3(1, 0, 0); // to find out when this happens
    }

    // The amount to increase i, j and k in each axis (either 1 or -1)
    int iStep, jStep, kStep;

    // The distance to the closest voxel boundary in map units
    float xDist, yDist, zDist;

    if (velocity.x > 0)
    {
        iStep = 1;
        xDist = (iStart.x - start.x + 1);
    }
    else
    {
        iStep = -1;
        xDist = (start.x - iStart.x);
    }

    if (velocity.y > 0)
    {
        jStep = 1;
        yDist = (iStart.y - start.y + 1);
    }
    else
    {
        jStep = -1;
        yDist = (start.y - iStart.y);
    }

    if (velocity.z > 0)
    {
        kStep = 1;
        zDist = (iStart.z - start.z + 1);
    }
    else
    {
        kStep = -1;
        zDist = (start.z - iStart.z);
    }

    // This variable is used to track the current progress throughout the ray march
    float t = 0.0;

    
    vec3 vInverted = abs(1 / velocity);

    // Determine the distance to the closest voxel boundary in units of t
    //  - These values indicate how far we have to travel along the ray to reach the next voxel
    //  - If any component of the direction is perpendicular to an axis, the distance is float.PositiveInfinity
    float xDistance = velocity.x == 0 ? 99999 : vInverted.x * xDist;
    float yDistance = velocity.y == 0 ? 99999 : vInverted.y * yDist;
    float zDistance = velocity.z == 0 ? 99999 : vInverted.z * zDist;

    while (t <= maximum)
    {
        // Exit check
        if (getBlock(ivec3(i, j, k)) != BLOCK_AIR)
        {
            hit = true;
            return vec3(0, 0, 1); // we hit a block!
        }

        // Determine the closest voxel boundary
        if (yDistance < xDistance)
        {
            if (yDistance < zDistance)
            {
                // Advance to the closest voxel boundary in the Y direction

                // Increment the chunk-relative position and the block access position
                j += jStep;

                // Update our progress in the ray 
                t = yDistance;

                // Set the new distance to the next voxel Y boundary
                yDistance += vInverted.y;

                // For collision purposes we also store the last axis that the ray collided with
                // This allows us to reflect particle velocity on the correct axis
                axis = AXIS_Y;
            }
            else
            {
                k += kStep;

                t = zDistance;
                zDistance += vInverted.z;
                axis = AXIS_Z;
            }
        }
        else if (xDistance < zDistance)
        {
            i += iStep;

            t = xDistance;
            xDistance += vInverted.x;
            axis = AXIS_X;
        }
        else
        {
            k += kStep;

            t = zDistance;
            zDistance += vInverted.z;
            axis = AXIS_Z;
        }
    }

    hit = false;

    return vec3(0, 0, 0);
}

vec3 getPixel(in vec2 pixel_coords)
{
    const vec2 frustumRay = (pixel_coords - (0.5 * screenSize)) / camera.frustumDiv;

    // rotate frustum space to world space
    const float temp = camera.cosPitch + frustumRay.y * camera.sinPitch;
    
    vec3 rayDir = normalize(vec3(frustumRay.x * camera.cosYaw + temp * camera.sinYaw,
                                 frustumRay.y * camera.cosPitch - camera.sinPitch,
                                 temp * camera.cosYaw - frustumRay.x * camera.sinYaw));

    bool hit = false;
    int axis = AXIS_X;

    vec3 color = rayMarch(camera.pos, rayDir, 60.0, hit, axis);


    return color;
}

void main() {
    // get index in global work group i.e x,y position
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    
    vec4 pixel = vec4(getPixel(pixel_coords), 1);

    // output to image
    imageStore(img_output, pixel_coords, pixel);
}