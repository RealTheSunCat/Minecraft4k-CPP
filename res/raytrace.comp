#version 430
layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba32f, binding = 0) uniform image2D img_output;
layout(r8ui, binding = 1) uniform uimage3D world;


#define AXIS_X 0
#define AXIS_Y 1
#define AXIS_Z 2

#define BLOCK_AIR 0
#define BLOCK_NEW 9

#define PASS_TEXTURE 0

#define select(condition, a, b) ((condition) ? (a) : (b))

struct Camera
{
    float cosYaw;
    float cosPitch;
    float sinYaw;
    float sinPitch;
};

uniform vec2 screenSize;
uniform Camera camera;
uniform vec2 frustumDiv;
uniform vec3 cameraPos;
uniform vec3 hoveredBlockPos;

uniform sampler2D textureAtlas;

uniform vec3 lightDirection;

uniform vec3 sunColor;
uniform vec3 ambColor;
uniform vec3 skyColor;

float minimum(in vec3 v)
{
    return min(min(v.x, v.y), v.z);
}

vec3 raytrace(in ivec2 pixel_coords)
{
    const vec2 frustumRay = (pixel_coords - (0.5 * screenSize)) / frustumDiv;

    // rotate frustum space to world space
    const float temp = camera.cosPitch + frustumRay.y * camera.sinPitch;
    
    vec3 rayDir = normalize(vec3(frustumRay.x * camera.cosYaw + temp * camera.sinYaw,
                                 frustumRay.y * camera.cosPitch - camera.sinPitch,
                                 temp * camera.cosYaw - frustumRay.x * camera.sinYaw));
    
    const float sunDot = clamp(dot(rayDir, lightDirection), 0, 1);

    float fogIntensity = 0.0f;
    float lightIntensity = 1.0f;
    vec3 pixelColor;
    
    float farthestRayDist = RENDER_DIST;
    
    bool wasBlockHit = false;

    // vector to move by so that we move on axis by 1
    const vec3 moveByDelta = rayDir / minimum(abs(rayDir));
    

    vec3 offsetFromBlockEdge = fract(cameraPos);
    if(rayDir.x > 0)
        offsetFromBlockEdge.x = 1.0f - offsetFromBlockEdge.x;
    if(rayDir.y > 0)
        offsetFromBlockEdge.y = 1.0f - offsetFromBlockEdge.y;
    if(rayDir.z > 0)
        offsetFromBlockEdge.z = 1.0f - offsetFromBlockEdge.z;
    
    float currentRayDist = 0;//offsetFromBlockEdge / abs(minimum(offsetFromBlockEdge));
        
    // set where the ray starts out
    vec3 curRayPos = cameraPos + moveByDelta * offsetFromBlockEdge;
    

    // do the raycast
    while (currentRayDist < farthestRayDist)
    {
        // convert ray coords to world coords
        const ivec3 rayWorldPos = ivec3(curRayPos.x - WORLD_SIZE, curRayPos.y - WORLD_HEIGHT, curRayPos.z - WORLD_SIZE);

        // if ray exits the world
        const vec3 lessThanWorld = step(vec3(0, -2, 0), rayWorldPos);
        const vec3 greaterThanWorld = step(vec3(WORLD_SIZE, WORLD_HEIGHT, WORLD_SIZE), rayWorldPos);
                
        bool inWorld = dot(lessThanWorld, lessThanWorld) * dot(greaterThanWorld, greaterThanWorld) == 0;
        if(!inWorld)
            break;
                
        const int blockHitID = rayWorldPos.y < 0 ? BLOCK_AIR : int(imageLoad(world, rayWorldPos).x);
            
        if (blockHitID != BLOCK_AIR) // we hit a block
        {
            const int texFetchX = int(mod((curRayPos.x + curRayPos.z) * TEXTURE_RES, TEXTURE_RES));
            const int texFetchY = int(mod(curRayPos.y * TEXTURE_RES, TEXTURE_RES) + TEXTURE_RES);

            const vec3 textureColor = texture(textureAtlas, vec2(
                                                texFetchX / float(TEXTURE_RES), 
                                                (texFetchY + TEXTURE_RES * 3 * blockHitID) / float(TEXTURE_RES * 48))).xyz;

            if (dot(textureColor, textureColor) != 0) { // pixel is not transparent
                pixelColor = textureColor;
                fogIntensity = currentRayDist / RENDER_DIST;
                wasBlockHit = true;
            }
                    
            farthestRayDist = currentRayDist;
        } else {
            curRayPos += rayDir;
            currentRayDist += 1.0f / length(rayDir);
        }
    }
    
    return wasBlockHit ? mix(pixelColor, skyColor, fogIntensity) * mix(ambColor, sunColor, lightIntensity)
                       : mix(skyColor, sunColor, 0.5 * pow(sunDot + 0.2, 5));
}

void main() {
    // get index in global work group i.e x,y position
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    
    vec4 pixel = vec4(raytrace(pixel_coords), 1);

    // output to image
    imageStore(img_output, pixel_coords, pixel);
}