#version 430
layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba32f, binding = 0) uniform image2D img_output;
layout(r8ui, binding = 1) uniform uimage3D blockData;

//! #define WORLD_SIZE 64
//! #define WORLD_HEIGHT 64

#define BLOCK_AIR 0

uniform sampler2D textureAtlas;

struct Camera
{
    vec3 pos;
    float cosYaw;
    float cosPitch;
    float sinYaw;
    float sinPitch;
    vec2 frustumDiv;
};

uniform vec2 screenSize;
uniform Camera camera;

// get the block at the specified position in the world
int getBlock(ivec3 coords)
{
    return int(imageLoad(blockData, coords).x);
}

#define AXIS_X 0
#define AXIS_Y 1
#define AXIS_Z 2

// Voxel ray marching from http://www.cse.chalmers.se/edu/year/2010/course/TDA361/grid.pdf
// Optimized by keeping block lookups within the current chunk, which minimises bitshifts, masks and multiplication operations
vec3 rayMarch(in vec3 start, vec3 velocity, float maximum, out bool hit, out int axis)
{
    int x = int(start.x);
    int y = int(start.y);
    int z = int(start.z);

    if (y < 0 || y >= WORLD_HEIGHT || x < 0 || x >= WORLD_SIZE || z < 0 || z >= WORLD_SIZE)
    {
        hit = false;
        return (start) / 100;
    }

    // Determine the chunk-relative position of the ray using a bit-mask
    int i = x - WORLD_SIZE;
    int j = y - WORLD_HEIGHT;
    int k = z - WORLD_SIZE;

    // Calculate the index of this block in the chunk data[] array
    int access = j + i * WORLD_SIZE + k * (WORLD_SIZE * WORLD_SIZE);

    // Calculate the end position of the ray
    vec3 end = start + velocity;

    // If the start and end positions of the ray both lie on the same coordinate on the voxel grid
    if (x == end.x && y == end.y && z == end.z)
    {
        return vec3(0, 0, 1);

        // If the block is empty
        if (getBlock(ivec3(i, j, k)) == BLOCK_AIR)
        {
            hit = false;
        }

        // Else the ray begins and ends within the same non-empty block
        else
        {
            hit = true;
        }

        return vec3(0, 0, 0);
    }

    // These variables are used to determine whether the ray has left the current working chunk.
    //  For example when travelling in the negative Y direction,
    //  if j == -1 then we have left the current working chunk
    int iComparison, jComparison, kComparison;

    // When leaving the current working chunk, the chunk-relative position must be reset.
    //  For example when travelling in the negative Y direction,
    //  j should be reset to CHUNK_SIZE - 1 when entering the new current working chunk
    int iReset, jReset, kReset;

    // When leaving the current working chunk, the access variable must also be updated.
    //  These values store how much to add or subtract from the access, depending on
    //  the direction of the ray:
    int xAccessReset, yAccessReset, zAccessReset;

    // The amount to increase i, j and k in each axis (either 1 or -1)
    int iStep, jStep, kStep;

    // When incrementing j, the chunk access is simply increased by 1
    // When incrementing i, the chunk access is increased by 32 (CHUNK_SIZE)
    // When incrementing k, the chunk access is increased by 1024 (CHUNK_SIZE_SQUARED)
    // These variables store whether to increase or decrease by the above amounts
    int xAccessIncrement, zAccessIncrement;

    // The distance to the closest voxel boundary in map units
    double xDist, yDist, zDist;

    if (velocity.x > 0)
    {
        iStep = 1;
        iComparison = WORLD_SIZE;
        iReset = 0;
        xAccessReset = -(WORLD_SIZE * WORLD_SIZE);
        xAccessIncrement = WORLD_SIZE;
        xDist = (x - start.x + 1);
    }
    else
    {
        iStep = -1;
        iComparison = -1;
        iReset = WORLD_SIZE - 1;
        xAccessReset = WORLD_SIZE * WORLD_SIZE;
        xAccessIncrement = -WORLD_SIZE;
        xDist = (start.x - x);
    }

    if (velocity.y > 0)
    {
        jStep = 1;
        jComparison = WORLD_SIZE;
        jReset = 0;
        yAccessReset = -WORLD_SIZE;
        yDist = (y - start.y + 1);
    }
    else
    {
        jStep = -1;
        jComparison = -1;
        jReset = WORLD_SIZE - 1;
        yAccessReset = WORLD_SIZE;
        yDist = (start.y - y);
    }

    if (velocity.z > 0)
    {
        kStep = 1;
        kComparison = WORLD_SIZE;
        kReset = 0;
        zAccessIncrement = WORLD_SIZE * WORLD_SIZE;
        zAccessReset = -(WORLD_SIZE * WORLD_SIZE * WORLD_SIZE);
        zDist = (z - start.z + 1);
    }
    else
    {
        kStep = -1;
        kComparison = -1;
        kReset = WORLD_SIZE - 1;
        zAccessIncrement = -(WORLD_SIZE * WORLD_SIZE);
        zAccessReset = (WORLD_SIZE * WORLD_SIZE * WORLD_SIZE);
        zDist = (start.z - z);
    }

    // This variable is used to track the current progress throughout the ray march
    double t = 0.0;

    velocity = normalize(velocity);
    double xInverted = abs(1 / velocity.x);
    double yInverted = abs(1 / velocity.y);
    double zInverted = abs(1 / velocity.z);

    // Determine the distance to the closest voxel boundary in units of t
    //  - These values indicate how far we have to travel along the ray to reach the next voxel
    //  - If any component of the direction is perpendicular to an axis, the distance is double.PositiveInfinity
    double xDistance = velocity.x == 0 ? 99999 : xInverted * xDist;
    double yDistance = velocity.y == 0 ? 99999 : yInverted * yDist;
    double zDistance = velocity.z == 0 ? 99999 : zInverted * zDist;

    while (t <= maximum)
    {
        // Exit check
        if (getBlock(ivec3(i, j, k)) != BLOCK_AIR)
        {
            hit = true;
            return vec3(1, 0, 0);
        }

        // Determine the closest voxel boundary
        if (yDistance < xDistance)
        {
            if (yDistance < zDistance)
            {
                // Advance to the closest voxel boundary in the Y direction

                // Increment the chunk-relative position and the block access position
                j += jStep;
                access += jStep;

                // Check if we have exited the current working chunk.
                // This means that j is either -1 or 32
                // TODO removed chunks lol

                // Update our progress in the ray 
                t = yDistance;

                // Set the new distance to the next voxel Y boundary
                yDistance += yInverted;

                // For collision purposes we also store the last axis that the ray collided with
                // This allows us to reflect particle velocity on the correct axis
                axis = AXIS_Y;
            }
            else
            {
                k += kStep;
                access += zAccessIncrement;

                // TODO removed chunks

                t = zDistance;
                zDistance += zInverted;
                axis = AXIS_Z;
            }
        }
        else if (xDistance < zDistance)
        {
            i += iStep;
            access += xAccessIncrement;

            // TODO removed chunks

            t = xDistance;
            xDistance += xInverted;
            axis = AXIS_X;
        }
        else
        {
            k += kStep;
            access += zAccessIncrement;

            // TODO removed chunks

            t = zDistance;
            zDistance += zInverted;
            axis = AXIS_Z;
        }
    }

    hit = false;
}

vec3 getPixel(in vec2 pixel_coords)
{
    const vec2 frustumRay = (pixel_coords - (0.5 * screenSize)) / camera.frustumDiv;

    // rotate frustum space to world space
    const float temp = camera.cosPitch + frustumRay.y * camera.sinPitch;
    
    vec3 rayDir = normalize(vec3(frustumRay.x * camera.cosYaw + temp * camera.sinYaw,
                                 frustumRay.y * camera.cosPitch - camera.sinPitch,
                                 temp * camera.cosYaw - frustumRay.x * camera.sinYaw));

    bool hit = false;
    int axis = AXIS_X;

    vec3 color = rayMarch(camera.pos, rayDir, 99.0, hit, axis);

    
//    if(hit)
//        color = vec3(0.5);
//    else
//        color = vec3(0.1);

    return color;
}

void main() {
    // get index in global work group i.e x,y position
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    
    vec4 pixel = vec4(getPixel(pixel_coords), 1);

    // output to image
    imageStore(img_output, pixel_coords, pixel);
}